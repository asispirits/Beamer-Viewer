<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Beamer_viewer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root{
        --bg:#0b1f3a;
        --beamer-width: 520px;
      }
      html, body { height: 100%; }
      body{
        margin:0;
        background: var(--bg);
        overflow: hidden;
        font-family: -apple-system, Segoe UI, system-ui, Arial, sans-serif;
      }

      #beamerBell.bv-bell{
        position: fixed;
        right: 18px;
        bottom: 18px;
        z-index: 2147483647;
        width: 74px;
        height: 74px;
        border-radius: 999px;
        border: 0;
        cursor: pointer;
        background: #19d3a2;
        box-shadow: 0 16px 50px rgba(0,0,0,.35);
        display: grid !important;
        place-items: center;
        transition: opacity .12s ease, transform .12s ease;
        opacity: 1 !important;
        visibility: visible !important;
        pointer-events: auto !important;
      }
      #beamerBell.bv-bell:active{ transform: translateY(1px); }
      #beamerBell.bv-bell svg{ width: 30px; height: 30px; fill: #0b1f3a; }

      body.beamer-open #beamerBell.bv-bell{
        opacity: 0 !important;
        pointer-events: none !important;
      }

      @keyframes bvPulse {
        0% { transform: scale(1); box-shadow: 0 16px 50px rgba(0,0,0,.35); }
        35% { transform: scale(1.08); box-shadow: 0 20px 70px rgba(25,211,162,.45); }
        70% { transform: scale(1.02); box-shadow: 0 18px 60px rgba(25,211,162,.35); }
        100% { transform: scale(1); box-shadow: 0 16px 50px rgba(0,0,0,.35); }
      }
      #beamerBell.bv-bell.pulse{ animation: bvPulse 650ms ease-in-out 1; }

      #beamerOverlay,
      #beamerOverlayWrapper,
      .beamerOverlay,
      .beamer-overlay,
      .beamer-panel,
      .beamerPanel,
      .beamer-changelog,
      .beamerChangelog{
        width: min(var(--beamer-width), 100vw) !important;
        max-width: min(var(--beamer-width), 100vw) !important;
        height: 100vh !important;
      }
    </style>
  </head>

  <body>
    <button class="bv-bell" id="beamerBell" type="button" aria-label="Open messages">
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path d="M12 22a2.5 2.5 0 0 0 2.45-2h-4.9A2.5 2.5 0 0 0 12 22Zm7-6V11a7 7 0 1 0-14 0v5l-2 2v1h18v-1l-2-2Z"/>
      </svg>
    </button>

    <script>
      (function () {
        const BEAMER_SRC = "https://app.getbeamer.com/js/beamer-embed.js";

        let refreshTimer = null;
        let booted = false;
        let refreshing = false;

        let lastManualCloseAt = 0;

        let manualCloseCooldownMs = 6000;
        let pulseOnNewMessage = true;
        let pulseMinIntervalMs = 15000;
        let lastPulseAt = 0;

        function now() { return Date.now(); }
        function bellEl() { return document.getElementById("beamerBell"); }

        function postToHost(type, payload) {
          try {
            if (window.chrome && window.chrome.webview && typeof window.chrome.webview.postMessage === "function") {
              window.chrome.webview.postMessage({ type, payload: payload || {} });
            }
          } catch (_) {}
        }

        function forceBellVisible() {
          const b = bellEl();
          if (!b) return;
          if (!document.body.classList.contains("beamer-open")) {
            b.style.display = "grid";
            b.style.visibility = "visible";
            b.style.opacity = "1";
            b.style.pointerEvents = "auto";
          }
        }

        function isElementVisible(el) {
          if (!el) return false;
          const cs = window.getComputedStyle(el);
          if (!cs) return false;
          if (cs.display === "none" || cs.visibility === "hidden") return false;
          if (Number(cs.opacity || "1") <= 0) return false;
          if (cs.pointerEvents === "none") return false;
          const rect = el.getBoundingClientRect();
          if (rect.width <= 0 || rect.height <= 0) return false;
          return true;
        }

        function widgetRootElements() {
          return [
            "#beamerOverlay",
            "#beamerOverlayWrapper",
            ".beamerOverlay",
            ".beamer-overlay",
            ".beamer-panel",
            ".beamerPanel",
            ".beamer-changelog",
            ".beamerChangelog"
          ];
        }

        function isWidgetOpenByDom() {
          for (const sel of widgetRootElements()) {
            const el = document.querySelector(sel);
            if (isElementVisible(el)) return true;
          }
          return false;
        }

        let lastOpen = null;

        function beamerReady() {
          return typeof window.Beamer === "object" && typeof window.Beamer.show === "function";
        }

        function tryHideWidget() {
          try {
            if (beamerReady() && typeof window.Beamer.hide === "function") window.Beamer.hide();
          } catch (_) {}
        }

        function enforceManualCloseIfNeeded(open) {
          const dt = now() - lastManualCloseAt;
          if (open && dt >= 0 && dt < manualCloseCooldownMs) {
            tryHideWidget();
            return false;
          }
          return open;
        }

        function syncOpenState() {
          let open = isWidgetOpenByDom();
          open = enforceManualCloseIfNeeded(open);

          if (open === lastOpen) {
            if (!open) forceBellVisible();
            return;
          }

          lastOpen = open;
          document.body.classList.toggle("beamer-open", open);
          if (!open) forceBellVisible();
        }

        function markManualClose() {
          lastManualCloseAt = now();
          document.body.classList.remove("beamer-open");
          lastOpen = false;
          forceBellVisible();
          setTimeout(syncOpenState, 50);
          setTimeout(syncOpenState, 250);
          setTimeout(syncOpenState, 900);
        }

        function clickIsInsideWidget(target) {
          if (!target || !(target instanceof Element)) return false;
          for (const sel of widgetRootElements()) {
            const root = document.querySelector(sel);
            if (root && root.contains(target)) return true;
          }
          return false;
        }

        function isLikelyWidgetCloseButton(target) {
          if (!target || !(target instanceof Element)) return false;

          const selectors = [
            "button[aria-label='Close']",
            "button[aria-label='close']",
            "button[title='Close']",
            "button[title='close']",
            "button[aria-label='Dismiss']",
            "button[aria-label='dismiss']",
            ".beamer-close",
            ".beamerClose",
            ".beamer_close",
            "[data-testid='close']",
            "[data-test='close']",
            "[data-action='close']"
          ];

          for (const sel of selectors) {
            if (target.matches(sel)) return true;
            const p = target.closest(sel);
            if (p) return true;
          }

          const text = (target.textContent || "").trim().toLowerCase();
          if (text === "close" || text === "Ã—" || text === "x") return true;

          return false;
        }

        const observer = new MutationObserver(() => syncOpenState());
        observer.observe(document.documentElement, { childList: true, subtree: true, attributes: true });

        document.addEventListener("click", (e) => {
          const t = e.target;
          if (!clickIsInsideWidget(t)) return;
          if (isLikelyWidgetCloseButton(t)) markManualClose();
        }, true);

        document.addEventListener("keydown", (e) => {
          if (e.key !== "Escape") return;
          if (isWidgetOpenByDom()) markManualClose();
        }, true);

        setInterval(() => {
          syncOpenState();
          forceBellVisible();
        }, 250);

        function pulseBell() {
          if (!pulseOnNewMessage) return;
          if (now() - lastPulseAt < pulseMinIntervalMs) return;
          if (document.body.classList.contains("beamer-open")) return;

          lastPulseAt = now();
          const b = bellEl();
          if (!b) return;

          b.classList.remove("pulse");
          void b.offsetWidth;
          b.classList.add("pulse");
          setTimeout(() => b.classList.remove("pulse"), 900);
        }

        function removeKnownBeamerDom() {
          const scriptEls = Array.from(document.querySelectorAll("script[src]"))
            .filter(s => (s.getAttribute("src") || "").includes("app.getbeamer.com/js/beamer-embed.js"));
          for (const s of scriptEls) s.remove();

          const knownSelectors = [
            "#beamerOverlay",
            "#beamerOverlayWrapper",
            "#beamerBadge",
            "#beamer-badge",
            ".beamerOverlay",
            ".beamer-overlay",
            ".beamer-panel",
            ".beamerPanel",
            ".beamer-changelog",
            ".beamerChangelog"
          ];

          for (const sel of knownSelectors) {
            const nodes = Array.from(document.querySelectorAll(sel));
            for (const n of nodes) n.remove();
          }

          const idPrefixNodes = Array.from(document.querySelectorAll("[id^='beamer']"));
          for (const n of idPrefixNodes) {
            const id = (n.getAttribute("id") || "").toLowerCase();
            if (id === "beamershell" || id === "beamerroot") continue;
            n.remove();
          }

          try { delete window.Beamer; } catch (_) { window.Beamer = undefined; }
        }

        function loadBeamerScript() {
          return new Promise((resolve, reject) => {
            const s = document.createElement("script");
            s.src = BEAMER_SRC + "?t=" + now();
            s.defer = true;
            s.onload = () => resolve(true);
            s.onerror = () => reject(new Error("beamer script failed"));
            document.head.appendChild(s);
          });
        }

        function waitForBeamerReady(timeoutMs = 8000, stepMs = 80) {
          return new Promise((resolve) => {
            const start = now();
            const tick = () => {
              if (beamerReady()) return resolve(true);
              if (now() - start >= timeoutMs) return resolve(false);
              setTimeout(tick, stepMs);
            };
            tick();
          });
        }

        function tryShow(retries = 120, delayMs = 120) {
          let n = 0;
          const tick = () => {
            n++;
            try {
              if (beamerReady()) {
                window.Beamer.show();
                return;
              }
            } catch (_) {}
            if (n >= retries) return;
            setTimeout(tick, delayMs);
          };
          tick();
        }

        function shouldReopenAfterRefresh(wasOpen) {
          if (!wasOpen) return false;
          const dt = now() - lastManualCloseAt;
          if (dt >= 0 && dt < manualCloseCooldownMs) return false;
          return true;
        }

        function readPossibleUnreadCount() {
          try {
            if (window.Beamer && typeof window.Beamer.unreadCount === "number") return window.Beamer.unreadCount;
            if (window.Beamer && typeof window.Beamer.getUnreadCount === "function") {
              const v = window.Beamer.getUnreadCount();
              if (typeof v === "number") return v;
            }
            if (window.Beamer && typeof window.Beamer.hasUnread === "function") {
              const v = window.Beamer.hasUnread();
              if (v === true) return 1;
              if (v === false) return 0;
            }
          } catch (_) {}
          return null;
        }

        async function refreshBeamerPreserveState() {
          if (refreshing) return;
          refreshing = true;

          const wasOpen = isWidgetOpenByDom();
          const beforeUnread = readPossibleUnreadCount();

          tryHideWidget();
          removeKnownBeamerDom();

          try {
            await loadBeamerScript();
          } catch (_) {
            refreshing = false;
            syncOpenState();
            return;
          }

          const ok = await waitForBeamerReady();
          syncOpenState();

          const afterUnread = readPossibleUnreadCount();

          const hasNew =
            (typeof beforeUnread === "number" && typeof afterUnread === "number" && afterUnread > beforeUnread) ||
            (typeof beforeUnread !== "number" && typeof afterUnread === "number" && afterUnread > 0);

          let delta = null;
          if (typeof beforeUnread === "number" && typeof afterUnread === "number") delta = afterUnread - beforeUnread;

          const dt = now() - lastManualCloseAt;
          const inCooldown = dt >= 0 && dt < manualCloseCooldownMs;

          const urgent =
            (delta !== null && delta > 1) ||
            inCooldown ||
            (beforeUnread === null && typeof afterUnread === "number" && afterUnread > 0);

          if (hasNew)
          {
            postToHost("new_message", { unread: afterUnread, delta });

            if (urgent)
            {
              postToHost("urgent_message", {
                unread: afterUnread,
                delta,
                reason: (delta !== null && delta > 1) ? "batch" : (inCooldown ? "cooldown" : "unknown_to_known")
              });
              if (ok) {
                lastManualCloseAt = 0;
                tryShow();
              }
            }

            if (!document.body.classList.contains("beamer-open")) pulseBell();
          }

          if (ok && shouldReopenAfterRefresh(wasOpen)) {
            tryShow();
          }

          refreshing = false;
        }

        window.__BV_FORCE_OPEN__ = function () {
          lastManualCloseAt = 0;
          tryShow();
        };

        window.__BV_BOOT__ = async function () {
          if (booted) return;
          booted = true;

          const cfg = window.__BV_CFG__ || {};
          const w = Number(cfg.widget_width || 520);
          const refreshMs = Number(cfg.refresh_ms || 60000);
          const autoOpen = !!cfg.auto_open_on_launch;

          manualCloseCooldownMs = Number(cfg.manual_close_cooldown_ms ?? 6000);
          if (!Number.isFinite(manualCloseCooldownMs) || manualCloseCooldownMs < 0) manualCloseCooldownMs = 6000;

          pulseOnNewMessage = !!cfg.pulse_on_new_message;

          pulseMinIntervalMs = Number(cfg.pulse_min_interval_ms ?? 15000);
          if (!Number.isFinite(pulseMinIntervalMs) || pulseMinIntervalMs < 0) pulseMinIntervalMs = 15000;

          document.documentElement.style.setProperty("--beamer-width", `${w}px`);

          window.beamer_config = {
            product_id: String(cfg.product_id || "vEjlRlWp82033"),
            user_id: String(cfg.user_id || ("local-" + now())),
            display: "right",
            button: false,
            alert: false,
            callback: function () {
              syncOpenState();
              if (autoOpen) tryShow();
            },
            onerror: function () {
              syncOpenState();
            }
          };

          await loadBeamerScript();
          await waitForBeamerReady();

          forceBellVisible();

          bellEl().addEventListener("click", () => {
            lastManualCloseAt = 0;
            tryShow();
          });

          if (autoOpen) tryShow();

          if (refreshTimer) clearInterval(refreshTimer);
          if (Number.isFinite(refreshMs) && refreshMs >= 1500) {
            refreshTimer = setInterval(refreshBeamerPreserveState, refreshMs);
          }
        };
      })();
    </script>
  </body>
</html>
